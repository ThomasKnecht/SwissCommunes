% Generated by roxygen2 (4.0.0): do not edit by hand
\name{swcGetMapping}
\alias{swcGetMapping}
\title{Compute a matching table between two lists of municipality IDs}
\usage{
swcGetMapping(swc = swcGetData(), ids.from, ids.to)
}
\arguments{
\item{swc}{Data as read by the function \code{swcReadData}, defaults to
\code{swcGetData()}.}

\item{ids.from}{A list of "source" municipality IDs}

\item{ids.to}{A list of "target" municipality IDs}
}
\value{
A data frame with columns prefixed by \code{from.} and \code{to} that
  represents the computed match.  The municipality IDs are stored in the
  columns \code{from.mId} and \code{to.mId}.  The columns
  \code{from.MergeType} and \code{to.MergeType} contain \code{valid} if
  the municipality is contained in both the input and the mapping table,
  \code{missing} if the municipality is missing from the input, and
  \code{extra} if the municipality is in the input but not in the mapping
  table; most columns are \code{NA} for such rows.  In addition, the column
  \code{MergeType} offers a summary of the "from" and "to" status.
}
\description{
For two lists of Swiss municipality IDs at any two points in time, this
function creates a data frame with two columns where each row represents
a match between municipality IDs.  This can be used as an intermediate
table for merging two data sets with municipality identifiers taken at
different, possibly unknown, points in time.
}
\examples{
logging::basicConfig("INFO")

library(pxR)
vz <- read.px("/home/muelleki/Downloads/px-d-40-1A01.px")
vzd <- as.data.frame(vz)
vzdm <- subset(vzd, grepl('^[.][.][.][.][.][.]([0-9]+).*$', Region))
vzdp <- transform(vzdm, MunicipalityID=as.numeric(gsub('^[.][.][.][.][.][.]([0-9]+).*$', '\\\\1', Region)))
mutIDPop <- plyr::dlply(
  vzdp,
  .(), #"Jahr",
  function(piece) {
    SwissCommunes:::getMostProbableMutationId(swc=swcGetData(), piece$MunicipalityID)
  }
)

(mutIDPop <- unique(unlist(mutIDPop)))

data(SwissBirths)
mutIDBirths <- plyr::dlply(
  SwissBirths,
  .(), #"Year",
  function(piece)
    SwissCommunes:::getMostProbableMutationId(swc=swcGetData(), municipalityIds=piece$MunicipalityID),
  .progress="text"
)

mutIDBirths <- unique(unlist(mutIDBirths))


ids.from <- with(vzdp, MunicipalityID)
ids.to <- with(SwissBirths, MunicipalityID)
setdiff(ids.from, ids.to)
setdiff(ids.to, ids.from)
mapping <- swcGetMapping(ids.from=ids.from, ids.to=ids.to)
with(mapping, sum(mapping$mId.from != mapping$mId.to))
subset(mapping, MatchType != "valid")
}

