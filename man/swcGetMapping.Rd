% Generated by roxygen2 (4.0.0): do not edit by hand
\name{swcGetMapping}
\alias{swcGetMapping}
\title{Compute a matching table between two lists of municipality IDs}
\usage{
swcGetMapping(swc = swcGetData(), ids.from, ids.to)
}
\arguments{
\item{swc}{Data as read by the function \code{swcReadData}, defaults to
\code{swcGetData()}.}

\item{ids.from}{A list of "source" municipality IDs, preferably a factor}

\item{ids.to}{A list of "target" municipality IDs, preferably a factor}
}
\value{
A data frame with columns prefixed by \code{from.} and \code{to} that
  represents the computed match.  The municipality IDs are stored in the
  columns \code{from.mId} and \code{to.mId}.  The columns
  \code{from.MergeType} and \code{to.MergeType} contain \code{valid} if
  the municipality is contained in both the input and the mapping table,
  \code{missing} if the municipality is missing from the input, and
  \code{extra} if the municipality is in the input but not in the mapping
  table; most columns are \code{NA} for such rows.  In addition, the column
  \code{MergeType} offers a summary of the "from" and "to" status: Rows with
  values other than \code{"valid"} or \code{"missing"} should be examined.
}
\description{
For two lists of Swiss municipality IDs at any two points in time, this
function creates a data frame with two columns where each row represents
a match between municipality IDs.  This can be used as an intermediate
table for merging two data sets with municipality identifiers taken at
different, possibly unknown, points in time.
}
\details{
It is advisable to use factors as list of municipality IDs.  By that,
comparisons and merges for municipality IDs are automatically checked for
compatibility.
}
\examples{
data(SwissPop)
data(SwissBirths)

# Show mismatch of municipality IDs:
ids.from <- with(SwissPop, MunicipalityID)
ids.to <- with(SwissBirths, MunicipalityID)
setdiff(ids.from, ids.to)
setdiff(ids.to, ids.from)

# Compute mapping and count non-matching municipality IDs:
mapping <- swcGetMapping(ids.from=ids.from, ids.to=ids.to)
with(mapping, sum(mapping$mIdAsNumber.from != mapping$mIdAsNumber.to))

# These should be looked at in some detail:
subset(mapping, !(MatchType \%in\% c("valid", "missing")))

# Test for injectivity. The result shows that the mapping is almost injective,
# only one "from" commune is mapped to more than one other "to" commune.
# This situation requires further examination.
valid.mapping <- subset(mapping, MatchType == "valid")
valid.mapping.dupes <- subset(valid.mapping, duplicated(mId.from))
(noninjective.mapping <- subset(valid.mapping, mId.from \%in\% valid.mapping.dupes$mId.from))
}

